/**
 * Backgammon AI Analysis API Route
 * Provides server-side AI analysis with access to environment variables
 */

const XAI_API_URL = 'https://api.x.ai/v1/chat/completions'

// Import proper game logic functions
import { getLegalMoves as getProperLegalMoves, getAvailableDice, relativeToAbsolute, canBearOff, getHighestOccupiedPoint, canEnterFromBar, calculateMoveDistance, validateMove } from '../../other-fun-stuff/backgammon-resources/opening-moves/utils/gameLogic.js'

// Helper functions copied from xgidParser.js
function charToCount(char) {
  if (char === '-') return 0
  if (char >= 'a' && char <= 'o') {
    // Lowercase: BLACK checkers, a=1, b=2, ..., o=15
    return char.charCodeAt(0) - 'a'.charCodeAt(0) + 1
  }
  if (char >= 'A' && char <= 'O') {
    // Uppercase: WHITE checkers, A=1, B=2, ..., O=15
    return char.charCodeAt(0) - 'A'.charCodeAt(0) + 1
  }
  return 0
}

function charToOwner(char) {
  if (char === '-') return null
  if (char >= 'a' && char <= 'o') return 'black'
  if (char >= 'A' && char <= 'O') return 'white'
  return null
}

function parseXGID(xgid) {
  if (!xgid || typeof xgid !== 'string') {
    return {
      blackBar: 0,
      whiteBar: 0,
      points: Array(24).fill({ count: 0, owner: null }),
      cubeValue: undefined,
      cubeOwner: undefined,
      player: undefined,
      dice: undefined
    }
  }

  const parts = xgid.split(':')
  const xg1 = parts[0] || ''
  const xg2 = parts[1]
  const xg3 = parts[2]
  const xg4 = parts[3]
  const xg5 = parts[4]

  if (xg1.length !== 26) {
    console.warn(`Invalid xg1 length: expected 26, got ${xg1.length}`)
    return {
      blackBar: 0,
      whiteBar: 0,
      points: Array(24).fill({ count: 0, owner: null }),
      cubeValue: undefined,
      cubeOwner: undefined,
      player: undefined,
      dice: undefined
    }
  }

  const blackBar = charToCount(xg1[0])

  const points = []
  for (let i = 1; i <= 24; i++) {
    const char = xg1[i]
    const count = charToCount(char)
    const owner = charToOwner(char)
    points.push({ count, owner })
  }

  const whiteBar = charToCount(xg1[25])

  let cubeValue = undefined
  if (xg2 !== undefined && xg2 !== '') {
    const parsed = parseInt(xg2, 10)
    if (!isNaN(parsed) && parsed >= 0 && parsed <= 6) {
      cubeValue = parsed
    }
  }

  let cubeOwner = undefined
  if (xg3 !== undefined && xg3 !== '') {
    const parsed = parseInt(xg3, 10)
    if (!isNaN(parsed) && (parsed === -1 || parsed === 0 || parsed === 1)) {
      cubeOwner = parsed
    }
  }

  let player = undefined
  if (xg4 !== undefined && xg4 !== '') {
    const parsed = parseInt(xg4, 10)
    if (!isNaN(parsed) && (parsed === -1 || parsed === 1)) {
      player = parsed
    }
  }

  let dice = undefined
  if (xg5 !== undefined && xg5 !== '') {
    if (/^\d{2}$/.test(xg5)) {
      dice = xg5
    }
  }

  return {
    blackBar,
    whiteBar,
    points,
    cubeValue,
    cubeOwner,
    player,
    dice
  }
}

// Generate move combinations from individual legal moves
function getLegalMoves(boardState, turnState) {
  const moveCombinations = []

  if (!turnState || !turnState.currentPlayer || turnState.dice.length === 0) {
    return moveCombinations
  }

  // Get all individual legal moves using the proper game logic
  const individualMoves = getProperLegalMoves(boardState, turnState)

  if (individualMoves.length === 0) {
    return moveCombinations
  }

  // Group moves by die value to create combinations
  const movesByDie = {}
  for (const move of individualMoves) {
    if (!movesByDie[move.dieUsed]) {
      movesByDie[move.dieUsed] = []
    }
    movesByDie[move.dieUsed].push(move)
  }

  const availableDice = getAvailableDice(turnState.dice, turnState.usedDice || [])
  const dieValues = [...new Set(availableDice)] // Unique die values

  // Special handling for doubles: combine identical moves
  if (dieValues.length === 1 && availableDice.length >= 2) {
    const dieValue = dieValues[0]
    const moves = movesByDie[dieValue] || []

    // Group identical moves (same from->to) and combine them
    const moveGroups = new Map()
    for (const move of moves) {
      const key = `${move.from}-${move.to}`
      if (!moveGroups.has(key)) {
        moveGroups.set(key, [])
      }
      moveGroups.get(key).push(move)
    }

    // Create combinations for doubles
    for (const [key, moveGroup] of moveGroups) {
      const count = Math.min(moveGroup.length, availableDice.length) // Max checkers we can move
      for (let numCheckers = Math.min(count, 4); numCheckers >= 1; numCheckers--) {
        if (numCheckers <= availableDice.length) {
          const moveArray = []
          for (let i = 0; i < numCheckers; i++) {
            moveArray.push({
              from: moveGroup[0].from,
              to: moveGroup[0].to,
              die: dieValue
            })
          }
          moveCombinations.push({
            moves: moveArray,
            description: formatMovesWithCounts(moveArray),
            totalPips: dieValue * numCheckers
          })
        }
      }
    }
  }

  // Generate move combinations for non-doubles
  if (dieValues.length >= 2) {
    const [die1, die2] = dieValues.sort((a, b) => b - a) // Sort descending

    // Try to create combinations using both dice
    const movesWithDie1 = movesByDie[die1] || []
    const movesWithDie2 = movesByDie[die2] || []

    // 1. Same checker with both dice - SIMULATE first move to find continuations
    // This handles moves like 24/13 (Lover's Leap) where the checker lands on an intermediate point
    for (const move1 of movesWithDie1) {
      // Simulate applying move1 to find continuation moves
      const intermediateState = applyMoveToBoard(boardState, move1, turnState.currentPlayer)
      const intermediateTurnState = {
        ...turnState,
        dice: [die2],
        usedDice: [die1]
      }
      const continuationMoves = getProperLegalMoves(intermediateState, intermediateTurnState)
      
      // Look for moves that start where move1 ended (same checker continues)
      for (const move2 of continuationMoves) {
        if (move2.from === move1.to) {
          const moveArray = [
            { from: move1.from, to: move1.to, die: die1 },
            { from: move2.from, to: move2.to, die: die2 }
          ]
          moveCombinations.push({
            moves: moveArray,
            description: formatMovesWithCounts(moveArray),
            totalPips: die1 + die2
          })
        }
      }
    }

    // Also try die2 first, then die1 (for moves like running with 5 then 6)
    for (const move1 of movesWithDie2) {
      const intermediateState = applyMoveToBoard(boardState, move1, turnState.currentPlayer)
      const intermediateTurnState = {
        ...turnState,
        dice: [die1],
        usedDice: [die2]
      }
      const continuationMoves = getProperLegalMoves(intermediateState, intermediateTurnState)
      
      for (const move2 of continuationMoves) {
        if (move2.from === move1.to) {
          const moveArray = [
            { from: move1.from, to: move1.to, die: die2 },
            { from: move2.from, to: move2.to, die: die1 }
          ]
          moveCombinations.push({
            moves: moveArray,
            description: formatMovesWithCounts(moveArray),
            totalPips: die1 + die2
          })
        }
      }
    }

    // 2. Different checkers with each die - include all combinations
    for (const move1 of movesWithDie1) {
      for (const move2 of movesWithDie2) {
        // Different checkers (different starting points)
        if (move1.from !== move2.from) {
          // Order moves by starting point (higher numbers first)
          const orderedMoves = [move1, move2].sort((a, b) => b.from - a.from)
          const moveArray = [
              { from: orderedMoves[0].from, to: orderedMoves[0].to, die: orderedMoves[0] === move1 ? die1 : die2 },
              { from: orderedMoves[1].from, to: orderedMoves[1].to, die: orderedMoves[1] === move1 ? die1 : die2 }
          ]
          moveCombinations.push({
            moves: moveArray,
            description: formatMovesWithCounts(moveArray),
            totalPips: die1 + die2
          })
        }
      }
    }
  }

  // 3. If no combinations work, add individual moves
  if (moveCombinations.length === 0) {
    for (const dieValue of dieValues) {
      const moves = movesByDie[dieValue] || []
      // Add ALL valid moves for this die, not just the first one
      for (const move of moves) {
        const moveArray = [{ from: move.from, to: move.to, die: dieValue }]
        moveCombinations.push({
          moves: moveArray,
          description: formatMovesWithCounts(moveArray),
          totalPips: dieValue
        })
      }
    }
  }

  // Remove duplicates based on final effect (description)
  // This handles cases where different intermediate paths lead to same result (e.g., 13/7/2 vs 13/8/2 both = 13/2)
  const uniqueCombinations = []
  const seen = new Set()

  for (const combo of moveCombinations) {
    // Use description as key since it combines sequential moves
    const key = combo.description
    if (!seen.has(key)) {
      seen.add(key)
      uniqueCombinations.push(combo)
    }
  }

  return uniqueCombinations
}

// Helper function to check if a move is valid
// Helper function to format move points for display
function formatMovePoint(point) {
  if (point === 0 || point === 25) return 'bar'
  if (point === -1 || point === -2) return 'off'
  return point.toString()
}

// Helper function to format moves with checker counts
// Also combines sequential moves of the same checker (e.g., 24/18 18/13 → 24/13)
function formatMovesWithCounts(moves) {
  if (!moves || moves.length === 0) return ''

  // First, combine sequential moves of the same checker
  const combinedMoves = []
  let i = 0
  while (i < moves.length) {
    const currentMove = { ...moves[i] }
    // Look for continuation moves (same checker continues)
    while (i + 1 < moves.length && moves[i + 1].from === currentMove.to) {
      currentMove.to = moves[i + 1].to
      i++
    }
    combinedMoves.push(currentMove)
    i++
  }

  // Count how many times each from->to pair appears
  const moveCounts = new Map()
  for (const move of combinedMoves) {
    const key = `${move.from}-${move.to}`
    moveCounts.set(key, (moveCounts.get(key) || 0) + 1)
  }

  // Convert to array of {from, to, count} and sort by from point (descending)
  const moveEntries = Array.from(moveCounts.entries()).map(([key, count]) => {
    const [from, to] = key.split('-').map(Number)
    return { from, to, count }
  }).sort((a, b) => b.from - a.from)

  // Format each move with count if > 1
  return moveEntries.map(({ from, to, count }) => {
    const fromStr = formatMovePoint(from)
    const toStr = formatMovePoint(to)
    return count > 1 ? `${fromStr}/${toStr}(${count})` : `${fromStr}/${toStr}`
  }).join(' ')
}

// ============================================================================
// DETERMINISTIC ENGINE - Reliable calculations for hybrid AI system
// ============================================================================

/**
 * Deep clone a board state
 */
function cloneBoardState(boardState) {
  return {
    blackBar: boardState.blackBar,
    whiteBar: boardState.whiteBar,
    points: boardState.points.map(p => ({ count: p.count, owner: p.owner })),
    cubeValue: boardState.cubeValue,
    cubeOwner: boardState.cubeOwner,
    player: boardState.player,
    dice: boardState.dice
  }
}

/**
 * Apply a single move to the board state (returns new state)
 */
function applyMoveToBoard(boardState, move, playerOwner) {
  const newState = cloneBoardState(boardState)
  const from = move.from
  const to = move.to
  
  // Handle moving from bar
  if (from === 0 || from === 25) {
    if (playerOwner === 'white') {
      newState.whiteBar = Math.max(0, newState.whiteBar - 1)
    } else {
      newState.blackBar = Math.max(0, newState.blackBar - 1)
    }
  } else {
    // Moving from a point
    const fromPoint = newState.points[from - 1]
    if (fromPoint.count > 0 && fromPoint.owner === playerOwner) {
      fromPoint.count--
      if (fromPoint.count === 0) {
        fromPoint.owner = null
      }
    }
  }
  
  // Handle moving to destination (bearing off or landing on point)
  if (to === -1 || to === -2 || to === 0) {
    // Bearing off - checker removed from board
  } else if (to >= 1 && to <= 24) {
    const toPoint = newState.points[to - 1]
    
    // Check if we're hitting an opponent blot
    const opponentOwner = playerOwner === 'white' ? 'black' : 'white'
    if (toPoint.count === 1 && toPoint.owner === opponentOwner) {
      // Hit! Send opponent to bar
      if (opponentOwner === 'white') {
        newState.whiteBar++
      } else {
        newState.blackBar++
      }
      toPoint.count = 0
      toPoint.owner = null
    }
    
    // Land on the point
    toPoint.count++
    toPoint.owner = playerOwner
  }
  
  return newState
}

/**
 * Calculate final board state after applying all moves
 */
function calculateFinalBoardState(boardState, moves, playerOwner) {
  let currentState = boardState
  for (const move of moves) {
    currentState = applyMoveToBoard(currentState, move, playerOwner)
  }
  return currentState
}

/**
 * Identify all blots (single checkers) for a player
 */
function identifyBlots(boardState, playerOwner) {
  const blots = []
  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.count === 1 && pointData.owner === playerOwner) {
      blots.push(point)
    }
  }
  return blots
}

/**
 * Identify all opponent checker positions
 */
function identifyOpponentPositions(boardState, playerOwner) {
  const opponentOwner = playerOwner === 'white' ? 'black' : 'white'
  const positions = []
  
  // Check bar
  const barCount = opponentOwner === 'white' ? boardState.whiteBar : boardState.blackBar
  if (barCount > 0) {
    positions.push({ point: opponentOwner === 'white' ? 25 : 0, count: barCount })
  }
  
  // Check all points
  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.count > 0 && pointData.owner === opponentOwner) {
      positions.push({ point, count: pointData.count })
    }
  }
  
  return positions
}

/**
 * Get all made points (2+ checkers) that would block movement
 */
function getMadePoints(boardState, playerOwner) {
  const madePoints = []
  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.count >= 2 && pointData.owner === playerOwner) {
      madePoints.push(point)
    }
  }
  return madePoints
}

/**
 * Calculate hit probability for a specific distance
 * Returns { probability, directRolls, indirectRolls, totalRolls }
 */
function calculateHitProbabilityForDistance(distance, blockedPoints = []) {
  if (distance <= 0 || distance > 24) {
    return { probability: 0, directRolls: 0, indirectRolls: 0, totalRolls: 0, rolls: [] }
  }
  
  const favorableRolls = []
  
  // All 36 possible dice combinations
  for (let d1 = 1; d1 <= 6; d1++) {
    for (let d2 = 1; d2 <= 6; d2++) {
      // Direct hit with single die (distance 1-6)
      if (distance <= 6 && (d1 === distance || d2 === distance)) {
        favorableRolls.push({ dice: [d1, d2], type: 'direct' })
        continue
      }
      
      // Indirect hit with both dice (distance 2-12)
      if (distance <= 12 && d1 + d2 === distance) {
        // Check if intermediate point is blocked
        const intermediateBlocked = blockedPoints.includes(distance - d1) || blockedPoints.includes(distance - d2)
        if (!intermediateBlocked) {
          favorableRolls.push({ dice: [d1, d2], type: 'indirect' })
          continue
        }
      }
      
      // Doubles can hit up to 24 (4 moves of same number)
      if (d1 === d2) {
        const stepSize = d1
        // Check if distance is reachable with 2, 3, or 4 steps of stepSize
        for (let numSteps = 2; numSteps <= 4; numSteps++) {
          if (stepSize * numSteps === distance) {
            // Check all intermediate points for blocks
            let blocked = false
            for (let step = 1; step < numSteps; step++) {
              if (blockedPoints.includes(stepSize * step)) {
                blocked = true
                break
              }
            }
            if (!blocked) {
              favorableRolls.push({ dice: [d1, d2], type: 'doubles' })
              break
            }
          }
        }
      }
    }
  }
  
  // Remove duplicates (same dice pair counted once)
  const uniqueRolls = []
  const seen = new Set()
  for (const roll of favorableRolls) {
    const key = roll.dice.sort((a, b) => a - b).join(',') + ':' + roll.type
    if (!seen.has(key)) {
      seen.add(key)
      // Count actual probability (e.g., [3,4] and [4,3] are 2/36)
      const d1 = roll.dice[0], d2 = roll.dice[1]
      const count = d1 === d2 ? 1 : 2
      uniqueRolls.push({ ...roll, count })
    }
  }
  
  // Calculate totals
  const directCount = uniqueRolls.filter(r => r.type === 'direct').reduce((sum, r) => sum + r.count, 0)
  const indirectCount = uniqueRolls.filter(r => r.type === 'indirect').reduce((sum, r) => sum + r.count, 0)
  const doublesCount = uniqueRolls.filter(r => r.type === 'doubles').reduce((sum, r) => sum + r.count, 0)
  const totalRolls = directCount + indirectCount + doublesCount
  
  return {
    probability: totalRolls / 36,
    directRolls: directCount,
    indirectRolls: indirectCount,
    doublesRolls: doublesCount,
    totalRolls,
    rolls: uniqueRolls
  }
}

/**
 * Calculate hit IMPACT based on blot position
 * A blot hit deep in your home board loses more progress than one in opponent's territory
 * Returns { impact: 0-1, pipsLost: number, zone: string }
 */
function calculateHitImpact(blotPoint, playerOwner) {
  const isWhite = playerOwner === 'white'
  
  // When hit, checker goes to bar and must re-enter in opponent's home board
  // For White: Re-enters at points 19-24, average ~21.5
  // For Black: Re-enters at points 1-6, average ~3.5
  // The pips lost is approximately the progress made toward bearing off
  
  let pipsLost, zone, impact
  
  if (isWhite) {
    // White moves toward point 1. Blot on point X = X pips of progress lost
    pipsLost = blotPoint
    
    if (blotPoint <= 6) {
      zone = 'HOME_BOARD'
      impact = 1.0 - (blotPoint - 1) * 0.03  // 1.0 for pt1, 0.85 for pt6
    } else if (blotPoint <= 12) {
      zone = 'OUTER_BOARD'
      impact = 0.8 - (blotPoint - 7) * 0.05  // 0.8 for pt7, 0.55 for pt12
    } else if (blotPoint <= 18) {
      zone = 'OPPONENT_OUTER'
      impact = 0.5 - (blotPoint - 13) * 0.05  // 0.5 for pt13, 0.25 for pt18
    } else {
      zone = 'OPPONENT_HOME'
      impact = 0.2 - (blotPoint - 19) * 0.02  // 0.2 for pt19, 0.1 for pt24
    }
  } else {
    // Black moves toward point 24. Blot on point X = (25-X) pips of progress lost
    pipsLost = 25 - blotPoint
    
    if (blotPoint >= 19) {
      zone = 'HOME_BOARD'
      impact = 1.0 - (24 - blotPoint) * 0.03  // 1.0 for pt24, 0.85 for pt19
    } else if (blotPoint >= 13) {
      zone = 'OUTER_BOARD'
      impact = 0.8 - (18 - blotPoint) * 0.05  // 0.8 for pt18, 0.55 for pt13
    } else if (blotPoint >= 7) {
      zone = 'OPPONENT_OUTER'
      impact = 0.5 - (12 - blotPoint) * 0.05  // 0.5 for pt12, 0.25 for pt7
    } else {
      zone = 'OPPONENT_HOME'
      impact = 0.2 - (6 - blotPoint) * 0.02  // 0.2 for pt6, 0.1 for pt1
    }
  }
  
  // Ensure impact stays in valid range
  impact = Math.max(0.1, Math.min(1.0, impact))
  
  return { impact, pipsLost, zone }
}

/**
 * Calculate total hit risk for a blot from all opponent positions
 * Now includes IMPACT assessment based on blot position
 * Returns the SET of hitting rolls for use in multi-blot combined risk calculation
 */
function calculateBlotRisk(blotPoint, opponentPositions, playerMadePoints, playerOwner) {
  // Determine movement direction
  const isWhite = playerOwner === 'white'
  
  const attackSources = []
  // Track all unique hitting rolls for this blot (for combined multi-blot calculation)
  const hittingRollsMap = new Map() // key: "d1,d2" (sorted), value: { dice, count }
  
  for (const oppPos of opponentPositions) {
    // Calculate distance based on movement direction
    let distance
    if (isWhite) {
      // White blot attacked by Black moving clockwise (higher points to lower)
      // Black moves from oppPos.point toward 24, so attacks points > oppPos.point
      // Actually Black moves 1 → 24, so from oppPos.point, Black can reach oppPos.point + dieValue
      distance = blotPoint - oppPos.point
    } else {
      // Black blot attacked by White moving counter-clockwise (lower points to higher)
      // White moves 24 → 1, so from oppPos.point, White can reach oppPos.point - dieValue
      distance = oppPos.point - blotPoint
    }
    
    if (distance <= 0) continue // Can't attack backwards
    
    // Get blocked points (opponent's made points act as blocks)
    const blockedByPlayer = playerMadePoints
    
    const hitProb = calculateHitProbabilityForDistance(distance, blockedByPlayer)
    
    if (hitProb.totalRolls > 0) {
      // Add to attack sources for reporting
      attackSources.push({
        fromPoint: oppPos.point,
        distance,
        probability: hitProb.probability,
        rolls: hitProb.totalRolls,
        type: hitProb.directRolls > 0 ? 'direct' : (hitProb.indirectRolls > 0 ? 'indirect' : 'doubles')
      })
      
      // Aggregate unique hitting rolls (for combined multi-blot calculation)
      for (const roll of hitProb.rolls) {
        const sortedDice = [...roll.dice].sort((a, b) => a - b)
        const key = sortedDice.join(',')
        if (!hittingRollsMap.has(key)) {
          hittingRollsMap.set(key, { dice: sortedDice, count: roll.count })
        }
      }
    }
  }
  
  // Calculate total unique hitting rolls (avoiding double-counting)
  let totalUniqueRolls = 0
  for (const roll of hittingRollsMap.values()) {
    totalUniqueRolls += roll.count
  }
  
  // Cap at 36 (can't have more than 100% chance)
  const effectiveRolls = Math.min(totalUniqueRolls, 36)
  const totalProbability = effectiveRolls / 36
  
  // Calculate hit IMPACT based on blot position
  const hitImpact = calculateHitImpact(blotPoint, playerOwner)
  
  // WEIGHTED RISK = probability × impact
  // A 50% hit chance in your home board (impact 1.0) = 0.5 weighted risk
  // A 50% hit chance in opponent's home (impact 0.15) = 0.075 weighted risk
  const weightedRisk = totalProbability * hitImpact.impact
  
  // Risk level based on WEIGHTED risk (not just probability)
  let riskLevel = 'LOW'
  if (weightedRisk >= 0.4) riskLevel = 'HIGH'
  else if (weightedRisk >= 0.2) riskLevel = 'MEDIUM'
  
  return {
    blotPoint,
    totalProbability,
    totalRolls: effectiveRolls,
    hitImpact: hitImpact.impact,
    pipsLost: hitImpact.pipsLost,
    zone: hitImpact.zone,
    weightedRisk,
    riskLevel,
    attackSources,
    // NEW: The set of all unique rolls that hit this blot (for multi-blot combined risk)
    hittingRolls: Array.from(hittingRollsMap.values())
  }
}

/**
 * Calculate COMBINED hit risk when multiple blots exist
 * Uses set union to find rolls that hit AT LEAST ONE blot
 * This is critical for moves like 24/18 13/8 which leave TWO blots
 */
function calculateCombinedMultiBlotRisk(blotRisks) {
  if (blotRisks.length === 0) {
    return { 
      combinedHitProbability: 0, 
      uniqueHittingRolls: 0, 
      multiHitRolls: 0,
      multiHitProbability: 0
    }
  }
  
  if (blotRisks.length === 1) {
    return { 
      combinedHitProbability: blotRisks[0].totalProbability,
      uniqueHittingRolls: blotRisks[0].totalRolls,
      multiHitRolls: 0,
      multiHitProbability: 0
    }
  }
  
  // Create a map to track which rolls hit which blots
  // Key: "d1,d2" (sorted dice), Value: { dice, count, blotPoints: Set }
  const rollToBlots = new Map()
  
  for (const blotRisk of blotRisks) {
    if (!blotRisk.hittingRolls) continue
    
    for (const roll of blotRisk.hittingRolls) {
      const key = roll.dice.join(',')
      if (!rollToBlots.has(key)) {
        rollToBlots.set(key, { 
          dice: roll.dice, 
          count: roll.count, 
          blotPoints: new Set([blotRisk.blotPoint])
        })
      } else {
        rollToBlots.get(key).blotPoints.add(blotRisk.blotPoint)
      }
    }
  }
  
  // Count unique rolls that hit at least one blot
  let uniqueHittingRolls = 0
  let multiHitRolls = 0
  
  for (const rollData of rollToBlots.values()) {
    uniqueHittingRolls += rollData.count
    if (rollData.blotPoints.size > 1) {
      multiHitRolls += rollData.count
    }
  }
  
  return {
    combinedHitProbability: uniqueHittingRolls / 36,
    uniqueHittingRolls,
    multiHitRolls,
    multiHitProbability: multiHitRolls / 36
  }
}

/**
 * Calculate BUILDER VALUE - checkers that threaten to make key points
 * ENHANCED: Accounts for target point VALUE, builder FLEXIBILITY, and stacking PENALTY
 * Key insight: Outer board builders (8-12) are more flexible than stacked home board checkers
 */
function calculateBuilderValue(boardState, playerOwner) {
  const isWhite = playerOwner === 'white'
  const builders = []
  
  // Target points with their VALUE (higher = more valuable to make)
  // For White: 7 (bar) > 5 > 4 > 3 > 2 > 1 (weakest)
  // For Black: 18 (bar) > 20 > 21 > 22 > 23 > 24 (weakest)
  const targetPointValues = isWhite 
    ? { 7: 3.0, 5: 2.5, 4: 2.0, 3: 1.5, 2: 0.5, 1: 0.3 }  // 2-point and 1-point are WEAK
    : { 18: 3.0, 20: 2.5, 21: 2.0, 22: 1.5, 23: 0.5, 24: 0.3 }
  
  const keyPoints = Object.keys(targetPointValues).map(Number)
  
  for (const targetPoint of keyPoints) {
    const targetData = boardState.points[targetPoint - 1]
    const targetValue = targetPointValues[targetPoint]
    
    // Skip if already made
    if (targetData.count >= 2 && targetData.owner === playerOwner) continue
    
    // Find builders that can reach this point
    const buildersForPoint = []
    
    for (let point = 1; point <= 24; point++) {
      const pointData = boardState.points[point - 1]
      if (pointData.count > 0 && pointData.owner === playerOwner) {
        // Calculate distance to target
        const distance = isWhite ? point - targetPoint : targetPoint - point
        
        // Builders are checkers 1-6 points away (reachable with one die)
        if (distance >= 1 && distance <= 6) {
          // Calculate builder quality based on source position
          let builderQuality = 1.0
          
          // OUTER BOARD BUILDERS (8-12 for White, 13-17 for Black) are MORE FLEXIBLE
          // They can reach multiple key points with different rolls
          // BUT: Keep bonus modest to not over-value builder-creating moves
          const outerBoardRange = isWhite ? [8, 12] : [13, 17]
          if (point >= outerBoardRange[0] && point <= outerBoardRange[1]) {
            builderQuality = 1.2  // 20% bonus for flexible outer board position (reduced from 50%)
          }
          
          // STACKING PENALTY: If source point has 3+ checkers, extra ones are less useful
          // A 6-stack means 4 "wasted" checkers that could be builders elsewhere
          if (pointData.count >= 3) {
            builderQuality *= 0.6  // 40% penalty for being part of a stack (increased)
          }
          if (pointData.count >= 5) {
            builderQuality *= 0.4  // Additional penalty for 5+ stack (very wasteful)
          }
          if (pointData.count >= 6) {
            builderQuality *= 0.3  // Severe penalty for 6+ stack (extremely wasteful)
          }
          
          buildersForPoint.push({
            fromPoint: point,
            distance,
            checkers: pointData.count,
            quality: builderQuality
          })
        }
      }
    }
    
    if (buildersForPoint.length > 0) {
      builders.push({
        targetPoint,
        pointName: getPointName(targetPoint, isWhite),
        targetValue,
        builders: buildersForPoint,
        builderCount: buildersForPoint.length,
        // Weighted builder score for this target
        weightedScore: buildersForPoint.reduce((sum, b) => sum + b.quality * targetValue, 0)
      })
    }
  }
  
  // Calculate total builder score with quality weighting
  const rawBuilderScore = builders.reduce((sum, b) => sum + b.weightedScore, 0)
  
  // CAP builder score to prevent builder-creating moves from dominating
  // Max builder score of 15 means builders can contribute significantly but not overwhelm
  // Point-making moves and escape moves should still be competitive
  const totalBuilderScore = Math.min(rawBuilderScore, 15)
  
  // Count only HIGH-VALUE targets (bar-point, 5-point, 4-point)
  const highValueTargets = builders.filter(b => b.targetValue >= 2.0)
  
  return {
    builders,
    totalBuilderScore,
    rawBuilderScore,  // Keep raw score for debugging
    keyPointsThreatenedCount: highValueTargets.length,  // Only count valuable targets
    allTargetsCount: builders.length
  }
}

/**
 * Calculate builder roll coverage
 * Measures how many die values can use existing builders to make valuable points
 */
function calculateBuilderRollCoverage(boardState, playerOwner) {
  const isWhite = playerOwner === 'white'

  const targetPointValues = isWhite
    ? { 7: 3.0, 5: 2.5, 4: 2.0, 3: 1.5, 2: 0.5, 1: 0.3 }
    : { 18: 3.0, 20: 2.5, 21: 2.0, 22: 1.5, 23: 0.5, 24: 0.3 }

  const targetPoints = Object.keys(targetPointValues).map(Number)
  let totalCoverageScore = 0
  const coverageByPoint = []

  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.owner !== playerOwner || pointData.count === 0) continue

    const coverageSet = new Set()
    let weightedTargetValue = 0

    for (const targetPoint of targetPoints) {
      const distance = isWhite ? point - targetPoint : targetPoint - point
      if (distance >= 1 && distance <= 6) {
        coverageSet.add(distance)
        weightedTargetValue += targetPointValues[targetPoint]
      }
    }

    if (coverageSet.size > 0) {
      // Limit stack contribution to avoid over-valuing heavy stacks
      const stackFactor = Math.min(2, pointData.count)
      const score = coverageSet.size * (weightedTargetValue / coverageSet.size) * stackFactor
      totalCoverageScore += score
      coverageByPoint.push({
        fromPoint: point,
        dieValues: Array.from(coverageSet).sort((a, b) => a - b),
        score
      })
    }
  }

  return {
    totalCoverageScore,
    coverageByPoint
  }
}

/**
 * Get descriptive name for a point
 */
function getPointName(point, isWhite) {
  if (isWhite) {
    if (point === 7) return 'bar-point'
    if (point === 5) return '5-point'
    if (point === 4) return '4-point'
    if (point === 3) return '3-point'
  } else {
    if (point === 18) return 'bar-point'
    if (point === 20) return '20-point'
    if (point === 21) return '21-point'
    if (point === 22) return '22-point'
  }
  return `${point}-point`
}

/**
 * Calculate ANCHOR POTENTIAL - back checkers positioned for advanced anchors
 * Advanced anchors: 18, 20, 21 points (for White); 4, 5, 7 points (for Black)
 */
function calculateAnchorPotential(boardState, playerOwner) {
  const isWhite = playerOwner === 'white'
  const anchors = []
  
  // Valuable anchor points in opponent's home board
  // For White: points 18-21 are advanced anchors (18 = bar-point, 20-21 = golden anchors)
  // For Black: points 4-7 are advanced anchors
  const anchorZone = isWhite ? { start: 18, end: 24 } : { start: 1, end: 7 }
  const goldenPoints = isWhite ? [20, 21] : [4, 5]
  const advancedPoints = isWhite ? [18, 19] : [6, 7]
  
  for (let point = anchorZone.start; point <= anchorZone.end; point++) {
    const pointData = boardState.points[point - 1]
    
    if (pointData.owner === playerOwner && pointData.count > 0) {
      let anchorType = 'back'
      let value = 1
      
      if (pointData.count >= 2) {
        anchorType = 'made'
        value = goldenPoints.includes(point) ? 3 : advancedPoints.includes(point) ? 2 : 1.5
      } else {
        // Single checker = potential anchor
        anchorType = 'potential'
        value = goldenPoints.includes(point) ? 2 : advancedPoints.includes(point) ? 1.5 : 1
      }
      
      anchors.push({
        point,
        checkers: pointData.count,
        anchorType,
        value,
        isGolden: goldenPoints.includes(point),
        isAdvanced: advancedPoints.includes(point)
      })
    }
  }
  
  const totalAnchorScore = anchors.reduce((sum, a) => sum + a.value, 0)
  const hasSplit = anchors.length >= 2  // Multiple back checkers = splitting advantage
  
  return {
    anchors,
    totalAnchorScore,
    hasSplit,
    potentialAnchorsCount: anchors.filter(a => a.anchorType === 'potential').length,
    madeAnchorsCount: anchors.filter(a => a.anchorType === 'made').length
  }
}

/**
 * Calculate PRIME strength and escape-prevention value
 * Primes block entry AND prevent opponent back checkers from escaping
 */
function calculatePrimeStrength(boardState, playerOwner) {
  const isWhite = playerOwner === 'white'
  const madePoints = []

  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.owner === playerOwner && pointData.count >= 2) {
      madePoints.push(point)
    }
  }

  if (madePoints.length === 0) {
    return {
      totalPrimeScore: 0,
      strongestPrimeLength: 0,
      primeSegments: [],
      escapePreventionScore: 0,
      entryBlockScore: 0
    }
  }

  // Find consecutive runs (prime segments)
  madePoints.sort((a, b) => a - b)
  const segments = []
  let current = [madePoints[0]]
  for (let i = 1; i < madePoints.length; i++) {
    if (madePoints[i] === madePoints[i - 1] + 1) {
      current.push(madePoints[i])
    } else {
      segments.push(current)
      current = [madePoints[i]]
    }
  }
  segments.push(current)

  const opponentOwner = isWhite ? 'black' : 'white'
  let escapePreventionScore = 0
  let totalPrimeScore = 0
  let strongestPrimeLength = 0

  for (const seg of segments) {
    const length = seg.length
    if (length < 2) continue
    strongestPrimeLength = Math.max(strongestPrimeLength, length)

    // Base prime value scales with length (longer primes are exponentially stronger)
    const basePrimeValue = length * 1.2 + (length >= 5 ? 1.5 : 0) + (length >= 6 ? 2.5 : 0)

    // Zone weight: primes in own home/outer board are more valuable
    const avgPoint = seg.reduce((sum, p) => sum + p, 0) / seg.length
    let zoneWeight = 1.0
    if (isWhite) {
      if (avgPoint <= 6) zoneWeight = 1.4
      else if (avgPoint <= 12) zoneWeight = 1.2
      else if (avgPoint <= 18) zoneWeight = 1.0
      else zoneWeight = 0.8
    } else {
      if (avgPoint >= 19) zoneWeight = 1.4
      else if (avgPoint >= 13) zoneWeight = 1.2
      else if (avgPoint >= 7) zoneWeight = 1.0
      else zoneWeight = 0.8
    }

    totalPrimeScore += basePrimeValue * zoneWeight

    // Escape prevention: opponent checkers trapped behind the prime
    // If opponent has checkers behind the prime in movement direction, the prime is more valuable
    if (isWhite) {
      const primeFront = Math.min(...seg)
      const trapped = countCheckersInRange(boardState, opponentOwner, 1, primeFront - 1)
      if (trapped > 0) {
        escapePreventionScore += trapped * (length * 0.6)
      }
    } else {
      const primeFront = Math.max(...seg)
      const trapped = countCheckersInRange(boardState, opponentOwner, primeFront + 1, 24)
      if (trapped > 0) {
        escapePreventionScore += trapped * (length * 0.6)
      }
    }
  }

  // Entry blocking: made points in opponent's entry board
  // White blocks Black entry on points 1-6, Black blocks White entry on points 19-24
  const entryBlockPoints = isWhite
    ? countMadePointsInRange(boardState, playerOwner, 1, 6)
    : countMadePointsInRange(boardState, playerOwner, 19, 24)
  const entryBlockScore = entryBlockPoints * 1.5

  return {
    totalPrimeScore: totalPrimeScore + escapePreventionScore + entryBlockScore,
    strongestPrimeLength,
    primeSegments: segments.map(seg => ({
      length: seg.length,
      points: seg
    })),
    escapePreventionScore,
    entryBlockScore
  }
}

/**
 * Calculate PRIME POTENTIAL
 * Measures near-prime extension opportunities from existing made points and slots
 */
function calculatePrimePotential(boardState, playerOwner) {
  const isWhite = playerOwner === 'white'
  const madePoints = []

  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.owner === playerOwner && pointData.count >= 2) {
      madePoints.push(point)
    }
  }

  if (madePoints.length === 0) {
    return { potentialScore: 0, extensions: [] }
  }

  madePoints.sort((a, b) => a - b)
  const segments = []
  let current = [madePoints[0]]
  for (let i = 1; i < madePoints.length; i++) {
    if (madePoints[i] === madePoints[i - 1] + 1) {
      current.push(madePoints[i])
    } else {
      segments.push(current)
      current = [madePoints[i]]
    }
  }
  segments.push(current)

  let potentialScore = 0
  const extensions = []

  for (const seg of segments) {
    const length = seg.length
    const front = Math.min(...seg)
    const back = Math.max(...seg)

    // Check extension on both ends if player has a single checker (slot)
    const frontPoint = front - 1
    if (frontPoint >= 1) {
      const frontData = boardState.points[frontPoint - 1]
      if (frontData.owner === playerOwner && frontData.count === 1) {
        const score = (length + 1) * 0.8
        potentialScore += score
        extensions.push({ point: frontPoint, newLength: length + 1, score })
      }
    }

    const backPoint = back + 1
    if (backPoint <= 24) {
      const backData = boardState.points[backPoint - 1]
      if (backData.owner === playerOwner && backData.count === 1) {
        const score = (length + 1) * 0.8
        potentialScore += score
        extensions.push({ point: backPoint, newLength: length + 1, score })
      }
    }
  }

  return { potentialScore, extensions }
}

/**
 * Calculate RETURN SHOTS - if your blots are hit, what's your chance of hitting back?
 * This compensates for risk by showing counter-attack potential
 */
function calculateReturnShots(boardState, playerOwner, blotRisks) {
  if (blotRisks.length === 0) {
    return { returnShotProbability: 0, returnShotSources: [], hasReturnShots: false }
  }
  
  const isWhite = playerOwner === 'white'
  const opponentOwner = isWhite ? 'black' : 'white'
  
  // Find opponent's potential blots (checkers that would be exposed after hitting us)
  // When opponent hits our blot, they often leave a blot themselves
  const returnShotSources = []
  
  // Check for existing opponent blots we can hit back
  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.count === 1 && pointData.owner === opponentOwner) {
      // Found an opponent blot - calculate our hit probability from bar or nearby checkers
      // After being hit, we'd enter from bar (point 25 for White, point 0 for Black)
      const barEntry = isWhite ? 25 : 0
      
      // Distance from bar to opponent blot
      const distanceFromBar = isWhite ? 25 - point : point
      
      if (distanceFromBar >= 1 && distanceFromBar <= 6) {
        // Direct return shot possible
        returnShotSources.push({
          targetPoint: point,
          distance: distanceFromBar,
          probability: 11 / 36,  // Direct hit probability
          type: 'direct'
        })
      } else if (distanceFromBar >= 2 && distanceFromBar <= 12) {
        // Indirect return shot possible
        const indirectProb = calculateHitProbabilityForDistance(distanceFromBar, [])
        if (indirectProb.totalRolls > 0) {
          returnShotSources.push({
            targetPoint: point,
            distance: distanceFromBar,
            probability: indirectProb.probability,
            type: 'indirect'
          })
        }
      }
    }
  }
  
  // Also consider that opponent hitting us often creates a blot for them
  // If we have builders nearby, we can hit that new blot
  const builderPositions = []
  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.count >= 1 && pointData.owner === playerOwner) {
      builderPositions.push({ point, count: pointData.count })
    }
  }
  
  // For each of our blots, estimate return shot potential
  for (const blotRisk of blotRisks) {
    // If opponent hits us on this point, they might leave a blot
    // We could hit back from our other checkers
    for (const builder of builderPositions) {
      if (builder.point === blotRisk.blotPoint) continue  // Can't hit from the blot itself
      
      const distance = isWhite ? builder.point - blotRisk.blotPoint : blotRisk.blotPoint - builder.point
      
      if (distance >= 1 && distance <= 6 && builder.count >= 1) {
        returnShotSources.push({
          targetPoint: blotRisk.blotPoint,
          fromPoint: builder.point,
          distance,
          probability: 11 / 36,
          type: 'counter-attack'
        })
      }
    }
  }
  
  // Calculate combined return shot probability
  let combinedReturnProb = 0
  for (const source of returnShotSources) {
    combinedReturnProb = Math.min(1, combinedReturnProb + source.probability * (1 - combinedReturnProb))
  }
  
  return {
    returnShotProbability: combinedReturnProb,
    returnShotSources,
    hasReturnShots: combinedReturnProb > 0.1
  }
}

/**
 * Identify points newly made (went from <2 to >=2 checkers)
 */
function identifyPointsMade(beforeState, afterState, playerOwner) {
  const newlyMade = []
  const strengthened = []
  
  for (let point = 1; point <= 24; point++) {
    const before = beforeState.points[point - 1]
    const after = afterState.points[point - 1]
    
    if (after.owner === playerOwner && after.count >= 2) {
      if (before.owner !== playerOwner || before.count < 2) {
        // Point was NOT made before, now IS made
        newlyMade.push(point)
      } else if (after.count > before.count) {
        // Point was already made, now has more checkers
        strengthened.push(point)
      }
    }
  }
  
  return { newlyMade, strengthened }
}

/**
 * Calculate pip counts for both players
 */
function calculatePipCounts(boardState) {
  let whitePips = 0
  let blackPips = 0
  
  // Count pips for checkers on points
  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.count > 0) {
      if (pointData.owner === 'white') {
        // White needs to bear off from point 1, so pip count is the point number
        whitePips += point * pointData.count
      } else if (pointData.owner === 'black') {
        // Black bears off from point 24, so pip count is (25 - point)
        blackPips += (25 - point) * pointData.count
      }
    }
  }
  
  // Add pips for checkers on bar
  // White enters at point 24 (25 pips away from bearing off)
  whitePips += boardState.whiteBar * 25
  // Black enters at point 1 (25 pips away from bearing off at point 24)
  blackPips += boardState.blackBar * 25
  
  return { white: whitePips, black: blackPips }
}

/**
 * Determine game stage and type for strategic emphasis
 * Stage: Early / Mid / Late (Race)
 * Type: Running / Holding / Blitz / Backgame / Contact
 */
function classifyGameContext(boardState, playerOwner) {
  const isWhite = playerOwner === 'white'
  const pipCounts = calculatePipCounts(boardState)
  const pipDiff = isWhite ? (pipCounts.white - pipCounts.black) : (pipCounts.black - pipCounts.white)
  const playerPips = isWhite ? pipCounts.white : pipCounts.black
  const opponentPips = isWhite ? pipCounts.black : pipCounts.white

  const whiteBack = countCheckersInRange(boardState, 'white', 19, 24)
  const blackBack = countCheckersInRange(boardState, 'black', 1, 6)
  const playerBack = isWhite ? whiteBack : blackBack
  const opponentBack = isWhite ? blackBack : whiteBack

  const whiteHomeMade = countMadePointsInRange(boardState, 'white', 1, 6)
  const blackHomeMade = countMadePointsInRange(boardState, 'black', 19, 24)
  const playerHomeMade = isWhite ? whiteHomeMade : blackHomeMade
  const opponentHomeMade = isWhite ? blackHomeMade : whiteHomeMade

  const playerAnchors = countMadePointsInRange(
    boardState,
    playerOwner,
    isWhite ? 19 : 1,
    isWhite ? 24 : 6
  )

  const contact = hasContact(boardState)

  let stage = 'MID'
  if (!contact) {
    stage = 'LATE (RACE)'
  } else {
    const totalMadePoints = whiteHomeMade + blackHomeMade +
      countMadePointsInRange(boardState, 'white', 7, 12) +
      countMadePointsInRange(boardState, 'black', 13, 18)
    if (totalMadePoints <= 4 && whiteBack >= 2 && blackBack >= 2) {
      stage = 'EARLY'
    } else {
      stage = 'MID'
    }
  }

  let type = 'CONTACT'
  if (!contact) {
    type = 'RUNNING'
  } else if (playerBack >= 3 && playerAnchors >= 2 && pipDiff > 10) {
    type = 'BACKGAME'
  } else if (playerHomeMade >= 3 && opponentBack >= 2) {
    type = 'BLITZ'
  } else if (playerAnchors >= 1) {
    type = 'HOLDING'
  }

  const emphasis = getStrategicEmphasis(stage, type)

  return {
    stage,
    type,
    playerPips,
    opponentPips,
    pipDiff,
    contact,
    playerBack,
    opponentBack,
    playerHomeMade,
    opponentHomeMade,
    playerAnchors,
    emphasis
  }
}

function countCheckersInRange(boardState, owner, startPoint, endPoint) {
  let count = 0
  for (let point = startPoint; point <= endPoint; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.owner === owner && pointData.count > 0) {
      count += pointData.count
    }
  }
  return count
}

function countMadePointsInRange(boardState, owner, startPoint, endPoint) {
  let count = 0
  for (let point = startPoint; point <= endPoint; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.owner === owner && pointData.count >= 2) {
      count += 1
    }
  }
  return count
}

function hasContact(boardState) {
  // Contact if both players have checkers in overlapping halves (likely to hit)
  const whiteInUpper = countCheckersInRange(boardState, 'white', 13, 24) > 0
  const blackInLower = countCheckersInRange(boardState, 'black', 1, 12) > 0
  return whiteInUpper && blackInLower
}

function getStrategicEmphasis(stage, type) {
  const emphasize = new Set()
  const deEmphasize = new Set()
  const notes = []

  if (stage === 'EARLY') {
    emphasize.add('DEVELOPMENT')
    emphasize.add('PRESSURE')
    emphasize.add('FLEXIBILITY')
    deEmphasize.add('SAFETY')
    notes.push('Early game favors constructive building over pure safety.')
  } else if (stage === 'MID') {
    emphasize.add('SAFETY')
    emphasize.add('PRESSURE')
    emphasize.add('TIMING')
    notes.push('Midgame balances safety, pressure, and timing.')
  } else {
    emphasize.add('TIMING')
    emphasize.add('SAFETY')
    deEmphasize.add('PRESSURE')
    deEmphasize.add('DEVELOPMENT')
    notes.push('Late race favors timing and safety over contact play.')
  }

  if (type === 'RUNNING') {
    emphasize.add('TIMING')
    emphasize.add('SAFETY')
    deEmphasize.add('PRESSURE')
    deEmphasize.add('HITTING')
  } else if (type === 'BLITZ') {
    emphasize.add('HITTING')
    emphasize.add('PRESSURE')
    emphasize.add('DEVELOPMENT')
  } else if (type === 'HOLDING') {
    emphasize.add('SAFETY')
    emphasize.add('TIMING')
    emphasize.add('FLEXIBILITY')
  } else if (type === 'BACKGAME') {
    emphasize.add('SAFETY')
    emphasize.add('FLEXIBILITY')
    emphasize.add('PRESSURE')
    deEmphasize.add('TIMING')
  }

  // Resolve conflicts: emphasized factors override de-emphasized ones
  for (const factor of emphasize) {
    if (deEmphasize.has(factor)) {
      deEmphasize.delete(factor)
    }
  }

  return {
    emphasize: Array.from(emphasize),
    deEmphasize: Array.from(deEmphasize),
    notes
  }
}

/**
 * Check if a move hits an opponent blot
 */
function checkForHit(beforeState, move, playerOwner) {
  const to = move.to
  if (to < 1 || to > 24) return null
  
  const opponentOwner = playerOwner === 'white' ? 'black' : 'white'
  const toPoint = beforeState.points[to - 1]
  
  if (toPoint.count === 1 && toPoint.owner === opponentOwner) {
    return { hitPoint: to, opponentOwner }
  }
  return null
}

/**
 * Build comprehensive verified analysis for a move combination
 */
function buildVerifiedMoveAnalysis(boardState, moveCombination, playerOwner) {
  const moves = moveCombination.moves || [moveCombination]
  
  // Calculate final board state
  const finalState = calculateFinalBoardState(boardState, moves, playerOwner)
  
  // Identify blots in final state
  const blots = identifyBlots(finalState, playerOwner)
  
  // Identify opponent positions for hit probability calculation
  const opponentPositions = identifyOpponentPositions(finalState, playerOwner)
  
  // Get player's made points (for blocking calculation)
  const playerMadePoints = getMadePoints(finalState, playerOwner)
  
  // Calculate hit risk for each blot
  const blotRisks = blots.map(blotPoint => 
    calculateBlotRisk(blotPoint, opponentPositions, playerMadePoints, playerOwner)
  )
  
  // Identify points made by this move
  const pointsAnalysis = identifyPointsMade(boardState, finalState, playerOwner)

  // Back checker escape progress (generalized)
  const isWhite = playerOwner === 'white'
  const opponentHomeRange = isWhite ? { start: 19, end: 24 } : { start: 1, end: 6 }
  const beforeBackCheckers = countCheckersInRange(boardState, playerOwner, opponentHomeRange.start, opponentHomeRange.end)
  const afterBackCheckers = countCheckersInRange(finalState, playerOwner, opponentHomeRange.start, opponentHomeRange.end)
  const backCheckerReduction = beforeBackCheckers - afterBackCheckers
  
  // Calculate pip counts
  const beforePips = calculatePipCounts(boardState)
  const afterPips = calculatePipCounts(finalState)
  const pipGain = playerOwner === 'white' 
    ? beforePips.white - afterPips.white 
    : beforePips.black - afterPips.black
  
  // Check for hits
  const hits = []
  let tempState = boardState
  for (const move of moves) {
    const hit = checkForHit(tempState, move, playerOwner)
    if (hit) hits.push(hit)
    tempState = applyMoveToBoard(tempState, move, playerOwner)
  }
  
  // NEW: Calculate TRUE combined hit probability using set union of hitting rolls
  // This correctly handles multiple blots (e.g., 24/18 13/8 leaves blots on 18 AND 24)
  const combinedRiskAnalysis = calculateCombinedMultiBlotRisk(blotRisks)
  
  // Keep weighted risk for impact-adjusted assessment
  let combinedWeightedRisk = 0
  for (const risk of blotRisks) {
    combinedWeightedRisk = Math.min(1, combinedWeightedRisk + risk.weightedRisk * (1 - combinedWeightedRisk))
  }
  
  // Determine overall risk level based on TRUE combined hit probability
  // This is the actual chance of getting hit SOMEWHERE
  let overallRiskLevel = 'LOW'
  if (combinedRiskAnalysis.combinedHitProbability >= 0.5) overallRiskLevel = 'HIGH'
  else if (combinedRiskAnalysis.combinedHitProbability >= 0.25) overallRiskLevel = 'MEDIUM'
  
  // NEW: Calculate BUILDER VALUE - checkers threatening key points
  const builderAnalysis = calculateBuilderValue(finalState, playerOwner)
  const builderCoverage = calculateBuilderRollCoverage(finalState, playerOwner)

  // NEW: Calculate ANCHOR POTENTIAL - back checkers for advanced anchors
  const anchorAnalysis = calculateAnchorPotential(finalState, playerOwner)

  // NEW: Calculate PRIME STRENGTH - blocks entry and prevents escape
  const primeAnalysis = calculatePrimeStrength(finalState, playerOwner)
  const primePotential = calculatePrimePotential(finalState, playerOwner)

  // Constructive potential combines builders, anchors, and primes (generalized, no point hard-coding)
  const constructivePotential = builderAnalysis.totalBuilderScore +
    anchorAnalysis.totalAnchorScore +
    primeAnalysis.totalPrimeScore +
    builderCoverage.totalCoverageScore +
    primePotential.potentialScore

  // NEW: Calculate RETURN SHOTS - counter-attack potential if hit
  const returnShotAnalysis = calculateReturnShots(finalState, playerOwner, blotRisks)
  
  return {
    moveDescription: moveCombination.description || formatMovesWithCounts(moves),
    finalState: {
      checkerPositions: finalState.points.map((p, i) => ({
        point: i + 1,
        count: p.count,
        owner: p.owner
      })).filter(p => p.count > 0),
      whiteBar: finalState.whiteBar,
      blackBar: finalState.blackBar
    },
    blots: {
      count: blots.length,
      positions: blots,
      risks: blotRisks,
      // NEW: True combined hit probability (using set union of hitting rolls)
      combinedHitProbability: combinedRiskAnalysis.combinedHitProbability,
      uniqueHittingRolls: combinedRiskAnalysis.uniqueHittingRolls,
      multiHitRolls: combinedRiskAnalysis.multiHitRolls,
      multiHitProbability: combinedRiskAnalysis.multiHitProbability,
      // Keep weighted risk for impact assessment
      combinedWeightedRisk,
      hasHomeBoardBlot: blotRisks.some(risk => risk.zone === 'HOME_BOARD'),
      overallRiskLevel
    },
    pointsMade: {
      newlyMade: pointsAnalysis.newlyMade,
      strengthened: pointsAnalysis.strengthened,
      totalNewPoints: pointsAnalysis.newlyMade.length
    },
    hits: {
      count: hits.length,
      details: hits
    },
    pips: {
      before: beforePips,
      after: afterPips,
      gain: pipGain
    },
    madePoints: playerMadePoints,
    // NEW: Strategic enhancement data
    builders: {
      score: builderAnalysis.totalBuilderScore,
      rollCoverageScore: builderCoverage.totalCoverageScore,
      keyPointsThreatened: builderAnalysis.keyPointsThreatenedCount,
      details: builderAnalysis.builders,
      rollCoverage: builderCoverage.coverageByPoint
    },
    anchors: {
      score: anchorAnalysis.totalAnchorScore,
      hasSplit: anchorAnalysis.hasSplit,
      potentialCount: anchorAnalysis.potentialAnchorsCount,
      madeCount: anchorAnalysis.madeAnchorsCount,
      details: anchorAnalysis.anchors
    },
    primes: {
      score: primeAnalysis.totalPrimeScore,
      strongestLength: primeAnalysis.strongestPrimeLength,
      segments: primeAnalysis.primeSegments,
      escapePreventionScore: primeAnalysis.escapePreventionScore,
      entryBlockScore: primeAnalysis.entryBlockScore,
      potentialScore: primePotential.potentialScore,
      potentialExtensions: primePotential.extensions
    },
    escapeProgress: {
      before: beforeBackCheckers,
      after: afterBackCheckers,
      reduction: backCheckerReduction
    },
    constructivePotential,
    returnShots: {
      probability: returnShotAnalysis.returnShotProbability,
      hasReturnShots: returnShotAnalysis.hasReturnShots,
      sources: returnShotAnalysis.returnShotSources
    }
  }
}

// ============================================================================
// END DETERMINISTIC ENGINE
// ============================================================================

// Flip XGID colors for BLACK player (present BLACK's position as WHITE's to AI)
function flipXgidColors(xgid) {
  const parts = xgid.split(':')
  const xg1 = parts[0]

  // Flip checker colors: uppercase (white) ↔ lowercase (black)
  const flippedXg1 = xg1.split('').map(char => {
    if (char >= 'A' && char <= 'O') return char.toLowerCase()  // White → Black
    if (char >= 'a' && char <= 'o') return char.toUpperCase()  // Black → White
    return char  // Keep dashes and other chars
  }).join('')

  // Flip bar counts
  const whiteBar = parseInt(parts[6] || '0')
  const blackBar = parseInt(parts[7] || '0')

  // Reconstruct XGID with flipped colors and swapped bars
  return `${flippedXg1}:${parts[1]}:${parts[2]}:${parts[3]}:${parts[4]}:${parts[5]}:${blackBar}:${whiteBar}:${parts[8] || '0'}:${parts[9] || '0'}`
}

// Convert XGID to human-readable board description
function xgidToReadableBoard(xgid, isFlipped = false) {
  const boardState = parseXGID(xgid)
  const descriptions = []

  // Describe occupied points
  for (let point = 1; point <= 24; point++) {
    const pointData = boardState.points[point - 1]
    if (pointData.count > 0) {
      let owner = pointData.owner
      // If XGID is flipped, adjust color references for display
      if (isFlipped) {
        owner = owner === 'white' ? 'black' : 'white'
      }
      const ownerName = owner === 'white' ? 'white' : 'black'
      const plural = pointData.count > 1 ? 's' : ''
      descriptions.push(`Point ${point}: ${pointData.count} ${ownerName} checker${plural}`)
    }
  }

  // Describe bar positions if any
  let whiteBar = boardState.whiteBar
  let blackBar = boardState.blackBar

  // If XGID is flipped, swap bar references for display
  if (isFlipped) {
    ;[whiteBar, blackBar] = [blackBar, whiteBar]
  }

  if (whiteBar > 0) {
    const plural = whiteBar > 1 ? 's' : ''
    descriptions.push(`White bar: ${whiteBar} checker${plural}`)
  }
  if (blackBar > 0) {
    const plural = blackBar > 1 ? 's' : ''
    descriptions.push(`Black bar: ${blackBar} checker${plural}`)
  }

  // If no checkers found, note that all points are empty
  if (descriptions.length === 0) {
    return 'All points empty'
  }

  return descriptions.join(', ')
}

export async function POST(request) {
  try {
    const { xgid, player, difficulty = 'intermediate', maxMoves = 5, debug = false } = await request.json()

    // Validate input
    if (!xgid) {
      return Response.json(
        { error: 'XGID is required' },
        { status: 400 }
      )
    }

    // Get API key from environment
    const XAI_API_KEY = process.env.XAI_API_KEY
    if (!XAI_API_KEY) {
      return Response.json(
        {
          move: null,
          reasoning: 'AI analysis not available - XAI_API_KEY not configured',
          confidence: 0.1,
          source: 'error'
        },
        { status: 200 }
      )
    }

    // PERSPECTIVE FLIPPING: If current player is BLACK, flip the board so AI analyzes from familiar WHITE perspective
    const isBlackPlayer = player === -1
    const xgidForAI = isBlackPlayer ? flipXgidColors(xgid) : xgid
    const aiPlayerColor = 'WHITE'  // Always tell AI it's WHITE's turn
    const aiOpponentColor = 'BLACK'  // Always tell AI opponent is BLACK

    // Parse position and generate legal moves (use original XGID for actual game logic)
    const boardState = parseXGID(xgid)
    const turnState = createTurnState(boardState, player)
    const allLegalMoves = getLegalMoves(boardState, turnState)

    // Collect debug information
    const debugInfo = debug ? {
      xgid,
      flippedXgid: isBlackPlayer ? xgidForAI : null,
      legalMoves: allLegalMoves.map(move => ({
        description: formatMove(move),
        totalPips: move.totalPips || 0
      })),
      prompt: '',
      response: ''
    } : null

    if (allLegalMoves.length === 0) {
      return Response.json({
        move: null,
        reasoning: "No legal moves available",
        confidence: 1.0,
        source: 'local'
      })
    }

    // Get top legal moves for AI analysis (increased from 5 to 10 for better selection)
    const topMoves = selectTopLegalMoves(allLegalMoves, Math.max(maxMoves, 10))

    // Get AI strategic analysis (use flipped XGID and always WHITE perspective)
    // HYBRID SYSTEM: Pass boardState to deterministic engine
    const aiAnalysis = await analyzeMovesWithAI(xgidForAI, topMoves, difficulty, 1, debugInfo, isBlackPlayer, boardState)

    // Validate and return best AI suggestion
    const result = validateAndReturnMove(aiAnalysis, topMoves)

    // Include debug info if requested
    if (debugInfo) {
      result.debug = debugInfo
    }

    return Response.json(result)

  } catch (error) {
    console.error('Backgammon AI API error:', error)

    // Return fallback response
    return Response.json({
      move: null,
      reasoning: 'AI analysis failed due to server error',
      confidence: 0.1,
      source: 'error'
    }, { status: 200 })
  }
}

/**
 * Create turn state for move validation
 */
function createTurnState(boardState, player) {
  const owner = player === 1 ? 'white' : 'black'
  let dice = []

  if (boardState.dice && boardState.dice !== '00') {
    const die1 = parseInt(boardState.dice[0])
    const die2 = parseInt(boardState.dice[1])

    // Handle doubles: if both dice are the same, allow 4 moves of that number
    if (die1 === die2) {
      dice = [die1, die1, die1, die1]
    } else {
      dice = [die1, die2]
    }
  }

  return {
    currentPlayer: owner,
    dice: dice,
    usedDice: [],
    isTurnComplete: false,
    mustEnterFromBar: (owner === 'black' ? boardState.blackBar : boardState.whiteBar) > 0,
    noLegalMoves: false
  }
}

/**
 * Select diverse top legal move combinations for AI analysis
 */
function selectTopLegalMoves(allMoves, maxMoves) {
  // In backgammon, you must use both dice if possible
  const bothDiceMoves = allMoves.filter(move => move.moves.length >= 2)
  const singleDieMoves = allMoves.filter(move => move.moves.length === 1)

  // If there are any both-dice moves available, only return those
  if (bothDiceMoves.length > 0) {
    return bothDiceMoves.slice(0, Math.min(maxMoves, bothDiceMoves.length))
  }

  // If no both-dice moves are possible, then single-die moves are allowed
  return singleDieMoves.slice(0, Math.min(maxMoves, singleDieMoves.length))
}

/**
 * Call xAI for strategic analysis using HYBRID system
 * Deterministic engine provides verified calculations, AI provides strategic evaluation
 */
async function analyzeMovesWithAI(xgid, moves, difficulty, player, debugInfo = null, isBlackPlayer = false, boardState = null) {
  const XAI_API_KEY = process.env.XAI_API_KEY

  // HYBRID SYSTEM: Build verified move analysis using deterministic engine
  const playerOwner = player === 1 ? 'white' : 'black'
  const verifiedAnalyses = moves.map((move, index) => ({
    moveNumber: index + 1,
    ...buildVerifiedMoveAnalysis(boardState, move, playerOwner)
  }))

  // Determine game context (stage + type) for strategic emphasis
  const gameContext = classifyGameContext(boardState, playerOwner)

  // Build hybrid prompt with verified data
  const prompt = buildHybridPrompt(xgid, moves, verifiedAnalyses, difficulty, player, isBlackPlayer, gameContext)

  // Store prompt and verified data in debug info
  if (debugInfo) {
    debugInfo.prompt = prompt
    debugInfo.verifiedAnalyses = verifiedAnalyses
    debugInfo.gameContext = gameContext
  }

  const response = await fetch(XAI_API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${XAI_API_KEY}`
    },
    body: JSON.stringify({
      model: 'grok-4-1-fast-non-reasoning',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 1000,  // Reduced - AI no longer needs to calculate, just evaluate
      temperature: 0.3
    })
  })

  if (!response.ok) {
    throw new Error(`xAI API error: ${response.status}`)
  }

  const data = await response.json()
  const aiResponse = data.choices[0].message.content

  // Store response in debug info
  if (debugInfo) {
    debugInfo.response = aiResponse
  }

  return parseAIResponse(aiResponse, isBlackPlayer)
}

/**
 * Build HYBRID prompt with verified deterministic data
 * AI only needs to evaluate strategy - all calculations are pre-computed
 */
function buildHybridPrompt(xgid, moves, verifiedAnalyses, difficulty, player, isBlackPlayer = false, gameContext = null) {
  const parts = xgid.split(':')
  const dice = parts[4] || '00'
  const aiPlayerColor = 'WHITE'
  const aiOpponentColor = 'BLACK'

  // Format verified move data for AI consumption
  const verifiedMoveData = verifiedAnalyses.map(analysis => {
    const blotSummary = analysis.blots.count === 0 
      ? 'NO BLOTS (completely safe)'
      : analysis.blots.risks.map(r => 
          `Pt${r.blotPoint}[${r.zone}]: ${(r.totalProbability * 100).toFixed(0)}% hit × ${(r.hitImpact * 100).toFixed(0)}% impact = ${(r.weightedRisk * 100).toFixed(0)}% weighted (${r.riskLevel})`
        ).join('; ')
    
    const pointsMadeSummary = analysis.pointsMade.totalNewPoints === 0
      ? 'No new points made'
      : `MAKES ${analysis.pointsMade.newlyMade.length > 0 ? analysis.pointsMade.newlyMade.map(p => `${p}-point`).join(', ') : 'no new points'}${analysis.pointsMade.strengthened.length > 0 ? ` (strengthens ${analysis.pointsMade.strengthened.join(', ')})` : ''}`
    
    const hitsSummary = analysis.hits.count === 0
      ? 'No hits'
      : `HITS opponent on ${analysis.hits.details.map(h => `pt${h.hitPoint}`).join(', ')}`
    
    // NEW: Builder value summary
    const builderSummary = analysis.builders.score === 0
      ? 'No builders for key points'
      : `Builders: ${analysis.builders.score.toFixed(1)} | Roll Coverage: ${analysis.builders.rollCoverageScore.toFixed(1)}`
    
    // NEW: Anchor potential summary
    const anchorSummary = analysis.anchors.score === 0
      ? 'No anchor potential'
      : `Anchors: ${analysis.anchors.score.toFixed(1)} (${analysis.anchors.hasSplit ? 'SPLIT' : 'single'}, ${analysis.anchors.potentialCount} potential, ${analysis.anchors.madeCount} made)`

    // NEW: Prime strength summary
    const primeSummary = analysis.primes.score === 0
      ? 'No prime strength'
      : `Primes: ${analysis.primes.score.toFixed(1)} (best ${analysis.primes.strongestLength}-prime, escape+entry value ${(
          analysis.primes.escapePreventionScore + analysis.primes.entryBlockScore
        ).toFixed(1)}) | Prime Potential: ${analysis.primes.potentialScore.toFixed(1)}`

    const constructiveSummary = `Constructive Potential: ${analysis.constructivePotential.toFixed(1)}`

    const escapeSummary = analysis.escapeProgress.reduction > 0
      ? `Escape Progress: -${analysis.escapeProgress.reduction} back checkers`
      : 'Escape Progress: none'
    
    // NEW: Return shots summary
    const returnShotSummary = analysis.returnShots.hasReturnShots
      ? `Return shots: ${(analysis.returnShots.probability * 100).toFixed(0)}% counter-attack potential`
      : 'No return shots'

    // NEW: Show TRUE combined hit probability (chance of getting hit AT LEAST ONCE)
    const hitProbSummary = analysis.blots.count > 1
      ? `HIT CHANCE: ${(analysis.blots.combinedHitProbability * 100).toFixed(1)}% (${analysis.blots.uniqueHittingRolls}/36 rolls hit at least one blot)`
      : `HIT CHANCE: ${(analysis.blots.combinedHitProbability * 100).toFixed(1)}% (${analysis.blots.uniqueHittingRolls}/36 rolls)`
    
    const multiHitWarning = analysis.blots.multiHitRolls > 0
      ? ` | DOUBLE-HIT: ${analysis.blots.multiHitRolls}/36 rolls hit BOTH blots!`
      : ''

    return `
MOVE ${analysis.moveNumber}: ${analysis.moveDescription}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VERIFIED FACTS (DO NOT RECALCULATE):
• Blots: ${analysis.blots.count} | ${blotSummary}
• ${hitProbSummary}${multiHitWarning}
• Impact-Weighted Risk: ${(analysis.blots.combinedWeightedRisk * 100).toFixed(1)}% | ${returnShotSummary}
• Points Made: ${pointsMadeSummary}
• ${builderSummary}
• ${anchorSummary}
• ${primeSummary}
• ${constructiveSummary}
• ${escapeSummary}
• Hits: ${hitsSummary} | Pip Gain: ${analysis.pips.gain}`
  }).join('\n')

  // Calculate race status from first analysis
  const racePips = verifiedAnalyses[0]?.pips.before || { white: 0, black: 0 }
  const raceStatus = racePips.white === racePips.black 
    ? 'EXACT TIE' 
    : racePips.white < racePips.black 
      ? `WHITE leads by ${racePips.black - racePips.white} pips`
      : `BLACK leads by ${racePips.white - racePips.black} pips`

  const contextSummary = gameContext
    ? `GAME CONTEXT (VERIFIED):
Stage: ${gameContext.stage}
Type: ${gameContext.type}
Contact: ${gameContext.contact ? 'YES' : 'NO'}
Back Checkers: You ${gameContext.playerBack}, Opponent ${gameContext.opponentBack}
Home Board Strength: You ${gameContext.playerHomeMade} made points, Opponent ${gameContext.opponentHomeMade} made points
Strategic Emphasis: ${gameContext.emphasis.emphasize.join(', ')}${gameContext.emphasis.deEmphasize.length ? ` | De-emphasize: ${gameContext.emphasis.deEmphasize.join(', ')}` : ''}
Notes: ${gameContext.emphasis.notes.join(' ')}`
    : 'GAME CONTEXT (VERIFIED): Unknown'

  return `You are a ${difficulty} level backgammon strategist. Your ONLY job is strategic evaluation.
ALL calculations below are VERIFIED and CORRECT - do NOT recalculate them.

POSITION: ${aiPlayerColor} to move | Dice: ${dice} | Race: ${raceStatus} (W:${racePips.white} B:${racePips.black})
${contextSummary}

═══════════════════════════════════════════════════════════════════════════════
VERIFIED MOVE ANALYSES (GOSPEL - TRUST THESE COMPLETELY):
═══════════════════════════════════════════════════════════════════════════════
${verifiedMoveData}

═══════════════════════════════════════════════════════════════════════════════
YOUR STRATEGIC EVALUATION TASK:
═══════════════════════════════════════════════════════════════════════════════

Using the VERIFIED data above, rate each move on these 7 strategic factors (0-10 scale):

STRATEGIC FACTORS (with multipliers):
1. HITTING (10x): Tempo gained by hitting opponent blots
2. DEVELOPMENT (9x): Point-making, anchor creation, prime building value
3. SAFETY (8x): Inverse of hit risk - higher = safer (use verified risk %)
4. PRESSURE (8x): Restricting opponent options, blocking entry points
5. DIVERSITY (8x): Checker spread, unstacking, positional flexibility
6. TIMING (7x): Race position improvement, pip efficiency
7. FLEXIBILITY (6x): Future roll options preserved

SCORING FORMULA:
Total = (Hitting×10) + (Dev×9) + (Safety×8) + (Press×8) + (Div×8) + (Time×7) + (Flex×6)

═══════════════════════════════════════════════════════════════════════════════
CRITICAL PRIORITY RULES (MUST FOLLOW):
1. POINT-MAKING + ZERO BLOTS = HIGHEST PRIORITY (Safety 10, Development 10)
2. A move that makes a point is ALWAYS better than a move that just creates builders
3. Zero-blot moves are dramatically safer than multi-blot moves
4. Builders are POTENTIAL value; made points are ACTUAL value
═══════════════════════════════════════════════════════════════════════════════

CONTEXT-AWARE WEIGHTING (USE GAME CONTEXT ABOVE):
• If a factor is listed in Strategic Emphasis: allow +1 to its rating (max 10)
• If a factor is listed in De-emphasize: allow -1 to its rating (min 0)
• Do NOT override point-making + zero-blot priority rules
• Use VERIFIED metrics (Constructive Potential, Builder Roll Coverage, Prime Potential, Escape Progress)
  to justify higher Development/Pressure when risk is modest

SAFETY RATING GUIDE (from TRUE combined HIT CHANCE %):
• HIT CHANCE is the TRUE probability of getting hit AT LEAST ONCE (set union of all hitting rolls)
• CRITICAL: With 2+ blots, combined risk is MUCH higher than individual risks!
• Example: 24/18 13/8 has ~94% combined hit chance (34/36 rolls hit at least one blot)
• Example: 24/13 has ~56% hit chance (single blot, much safer!)
• Use HIT CHANCE for primary safety rating:
  - 0-20% hit chance → Safety: 9-10 (very safe)
  - 20-40% hit chance → Safety: 7-8 (reasonably safe)
  - 40-60% hit chance → Safety: 5-6 (risky)
  - 60-80% hit chance → Safety: 3-4 (very risky)
  - 80%+ hit chance → Safety: 1-2 (almost certain to be hit)
• DOUBLE-HIT PENALTY: If rolls can hit BOTH blots, reduce safety by 1 additional point
• Return shots 30%+: Add +1 to safety (counter-attack compensates)
• Impact-weighted risk helps distinguish WHERE you're hit (home board = worse)

DEVELOPMENT RATING GUIDE:
• CRITICAL: POINT-MAKING is ALWAYS more valuable than builders alone!
• Makes home board point (1-6) with 0 blots: Development = 10 (MAXIMUM)
• Makes home board point (1-6) with blots: Development = 8-9
• Makes outer board point (7-12): Development = 6-8
• Makes anchor in opponent territory: Development = 9-10
• ESCAPES a back checker (24→13 or similar running move): Development = 7-8 (complete escape is REAL progress)
• NO points made, but high builders or roll coverage (10+): Development = 5-6
• NO points made, moderate builders or roll coverage (5-10): Development = 4-5
• NO points made, low builders: Development = 2-3
• NEVER rate a builder-only move higher than a point-making OR complete-escape move on Development!
• PRIME strength matters: Longer primes add development (especially if they block escape/entry)
• Prime potential (near-prime extensions) adds +1 to development when present

PRESSURE RATING GUIDE:
• Splitting back checkers restricts opponent development: +2 to pressure
• Builders threatening bar-point create pressure: +1 to pressure
• Checker in opponent's home board forces them to play around it: +1 to pressure
• Prime escape prevention: If primes trap opponent back checkers, add +1 to pressure

RESPONSE FORMAT (be concise):

ANALYSIS:
[For each move, provide: Move X: H:[0-10] D:[0-10] S:[0-10] P:[0-10] Dv:[0-10] T:[0-10] F:[0-10] = TOTAL]

BEST_MOVE: [number]
REASONING: [2-3 sentences explaining why this move has the highest strategic value based on factor trade-offs]
CONFIDENCE: [0.0-1.0]

CRITICAL: Trust the verified data. Do NOT recalculate blots, hit probabilities, or points made.`
}

/**
 * LEGACY: Original AI-only prompt (preserved for reference)
 * Replaced by buildHybridPrompt which uses deterministic engine
 */
function buildAnalysisPrompt_LEGACY(xgid, moves, difficulty, player, isBlackPlayer = false) {
  // Parse XGID to get player and dice info
  const parts = xgid.split(':')
  const playerNum = parseInt(parts[3] || '1')
  const dice = parts[4] || '00'

  // Always tell AI it's WHITE's perspective (flip colors if needed)
  const aiPlayerColor = 'WHITE'
  const aiOpponentColor = 'BLACK'

  const moveList = moves.map((move, i) =>
    `${i + 1}. ${formatMove(move)}`
  ).join('\n')

  return `You are a ${difficulty} level backgammon expert analyzing from ${aiPlayerColor}'s perspective.

Current position:
Board state: ${xgidToReadableBoard(xgid, isBlackPlayer)}
${aiPlayerColor} to move with dice: ${dice}

CRITICAL: ANALYZE THE XGID FIRST - Do NOT assume positions from memory!

BOARD STATE ANALYSIS:
- The readable board state above shows EXACT checker positions
- Points not mentioned are EMPTY (0 checkers)
- You MUST use the provided board state, not assume standard positions

STANDARD STARTING POSITIONS (for reference only):
- WHITE: 2 on 24-pt, 5 on 13-pt, 3 on 8-pt, 5 on 6-pt
- BLACK: 2 on 1-pt, 5 on 12-pt, 3 on 17-pt, 5 on 19-pt
- But ALWAYS check the XGID for the CURRENT state!

VISUAL BOARD LAYOUT:
Bottom row (points 1-6): WHITE's home board - bear-off zone
Bottom row (points 7-12): WHITE's outer board
Top row (points 13-18): BLACK's outer board
Top row (points 19-24): BLACK's home board

MOVEMENT DIRECTION:
- WHITE moves counter-clockwise: 24 → 23 → ... → 1 (bear off)
- BLACK moves clockwise: 1 → 2 → ... → 24 (bear off)

POINT STATUS DETERMINATION:
- 0 checkers = EMPTY point (can be "slotted" with 1 checker)
- 1 checker = BLOT (can be hit by opponent)
- 2+ checkers = MADE POINT (safe blockade)

MANDATORY ANALYSIS SEQUENCE (COMPLETE IN ORDER):

STEP 1 - COMPLETE BOARD INVENTORY (MANDATORY FIRST):
□ POINT-BY-POINT INVENTORY: List EVERY point 1-24 individually
□ For each point: "Point X: [exact count] [white/black] checkers" or "Point X: empty"
□ NO SUMMARIZATION: Never say "points X-Y empty" without checking each point
□ BAR CHECKERS: "White bar: X checkers, Black bar: Y checkers"

OPTIMIZED OUTPUT FORMAT (For Human Learning):
□ INSTEAD OF verbose point-by-point listing, provide STRATEGIC SUMMARY:
□ "White: [key formations/points with checker counts]"
□ "Black: [key formations/points with checker counts]"
□ "Analysis: [strategic balance, prime development, race status]"
□ PRIME TERMINOLOGY: Prime = 6+ consecutive made points | 5-prime = 5 consecutive | 4-prime = 4 consecutive | etc.
□ EXAMPLE: "White: Strong points 6(5), 8(3), 13(5), 24(2) | Black: Strong points 1(2), 12(5), 17(3), 19(5) | Equal race, mutual development focus"

STEP 2 - BLOT IDENTIFICATION (AFTER COMPLETE INVENTORY):
□ SCAN ALL POINTS: Identify every single checker (blots = exactly 1 checker)
□ LIST ALL BLOTS: "Blots: Point X ([color]), Point Y ([color])..."
□ VERIFY NO ERRORS: Confirm no made points (2+ checkers) are called blots

STEP 3 - SYSTEMATIC VULNERABILITY ASSESSMENT:
□ FOR EACH BLOT: Check attack possibilities methodically
□ COMPREHENSIVE CHECK: List ALL opponent checkers on the board (no distance restriction)
□ ATTACK CALCULATION: For each opponent checker, determine if it can reach the blot via:
□ DIRECT HITS: Distance 1-6 (single die = exact distance)
□ INDIRECT HITS: Distance 2-12 (two dice sum to exact distance)
□ DOUBLES HITS: Distance up to 24 (four moves with doubles)
□ CONCLUSION: Only call "safe" after checking ALL opponent checkers and ALL possible attack combinations

STEP 3.5 - HIT PROBABILITY CALCULATION (MANDATORY FOR ALL BLOTS):
□ For each blot, check ALL opponent checkers for hit possibilities (no distance restriction)
□ For EACH opponent checker, calculate if it can reach the blot:
□ DIRECT HITS: Distance 1-6 (11 rolls for single die = exact distance)
□ INDIRECT HITS: Distance 2-12 (rolls where two dice sum to exact distance)
□ DOUBLES HITS: Distance up to 24 (rolls allowing four moves with doubles)
□ TOTAL PROBABILITY: Sum favorable rolls from ALL possible attackers / 36
□ RISK LEVELS: LOW (<25%), MEDIUM (25-50%), HIGH (>50%)
□ COMPREHENSIVE: Never assume "safe" - check EVERY opponent checker systematically
□ EXAMPLE: Blot on point 9 with Black checker on point 1 (distance 8): Can be hit with 6+2, 5+3, 4+4, etc. = significant risk

STEP 4 - RACE CALCULATION (STRATEGIC SUMMARY):
□ CALCULATE EXACTLY: WHITE uses absolute point numbers, BLACK uses relative (25 - point)
□ INTERNAL VERIFICATION: Verify all pip calculations are accurate
□ OPTIMIZED OUTPUT: Provide strategic summary, not step-by-step math
□ FORMAT: "White: [total] pips ([point:contribution, ...]) | Black: [total] pips ([point:contribution, ...]) | [race status and strategic implications]"
□ EXAMPLE: "White: 167 pips (6:30, 8:24, 13:65, 24:48) | Black: 167 pips (1:48, 12:65, 17:24, 19:30) | Equal race - mutual development focus"

STEP 5 - STRATEGIC ANALYSIS (ONLY AFTER ABOVE STEPS):
□ USE VERIFIED DATA: Reference specific points and their confirmed status
□ AVOID ASSUMPTIONS: Base analysis only on completed inventory and calculations

ABSOLUTELY FORBIDDEN ASSUMPTIONS:
❌ "Points X-Y are empty" (check each point individually first)
❌ "Player leads in race" (calculate actual pip distances)
❌ "Blot is safe/vulnerable" (verify all attack routes systematically)
❌ "Standard position" (use ONLY provided board state)
❌ "Obvious threats" (methodically verify each possibility)

MANDATORY RESPONSE STRUCTURE:
BOARD_INVENTORY: [Strategic summary of formations and key positions - highlight primes, strong points, and position balance]
BLOT_ANALYSIS: [Systematic vulnerability assessment]
RACE_ANALYSIS: [Strategic race summary with pip totals and implications]
STRATEGIC_ANALYSIS: [Move evaluation using verified data]

Legal moves to consider:
${moveList}

CRITICAL BOARD LAYOUT (MEMORIZE THIS):
Points 1-6: YOUR (WHITE) home board - your safe zone where you bear off checkers
Points 7-12: YOUR (WHITE) outer board - your side of the board
Points 13-18: OPPONENT (BLACK) outer board - opponent's side of the board
Points 19-24: OPPONENT (BLACK) home board - opponent's safe zone

POINT OWNERSHIP RULES:
- Points 1-6: ALWAYS YOURS (WHITE) - never call these "BLACK's points"
- Points 19-24: ALWAYS BLACK'S - opponent's safe zone
- Points 7-18: Shared territory (outer boards)

MOVEMENT DIRECTION:
- YOU (WHITE) move FROM HIGHER numbers TO LOWER numbers (24→1)
- BLACK moves FROM LOWER numbers TO HIGHER numbers (1→24)

IMPORTANT TERMINOLOGY:
- "Making a point" means placing two checkers on the same point to create a blockade
- "Slotting a point" means placing a SINGLE checker on an EMPTY point (point with 0 checkers)
- A "blot" is a single checker that can be hit by opponent
- Regular moves to occupied points (1+ checkers) don't have special terminology

CRITICAL BASIC CONCEPTS (MASTER THESE FIRST):

BLOT DEFINITION:
- A "blot" is EXACTLY ONE checker on a point (vulnerable to being hit)
- MULTIPLE checkers on a point = MADE POINT (safe blockade, NOT a blot)
- NEVER call a point with 2+ checkers a "blot" - this is WRONG terminology
- Example: Point 6 with 5 checkers = made point, NOT a blot
- Example: Point 3 with 1 checker = blot, vulnerable to attack

BAR-POINT DEFINITION:
- WHITE's "bar-point" = point 7 (point physically adjacent to the bar)
- BLACK's "bar-point" = point 18 (point physically adjacent to the bar)
- Point 24 is WHITE's farthest point from WHITE's home board, NOT the bar-point
- Point 1 is BLACK's farthest point from BLACK's home board, NOT the bar-point

ATTACK RULES - COMPREHENSIVE:
- Any checker can attack any blot within hitting range, regardless of board section
- Movement direction determines valid attack paths
- Distance calculation: Absolute distance in movement direction

VULNERABILITY ANALYSIS - COMPLETE:
- A blot can be hit from ANY opponent checker that can reach it
- Check ALL opponent checkers for potential attacks (no distance limit)
- DIRECT HITS: Single die = exact distance (1-6 spaces)
- INDIRECT HITS: Two dice sum to exact distance (2-12 spaces)
- DOUBLES HITS: Four moves can reach up to 24 spaces
- Calculate TOTAL hit probability from ALL possible attackers
- Never assume "safe" without checking EVERY opponent checker

HIT PROBABILITY CALCULATION (MANDATORY):
- Backgammon has 36 equally likely dice rolls
- For each blot, calculate EXACT hit probability, not just "can be hit"
- DIRECT HITS: 11 rolls (any roll with ≥1 die = distance)
- INDIRECT HITS: Additional rolls where both dice sum to exact distance
- EXAMPLE: Blot 4 spaces away = 15/36 ≈ 41.7% (11 direct + 4 indirect: 31,13,11,22)
- RISK LEVELS: LOW (<25%), MEDIUM (25-50%), HIGH (>50%)
- CRITICAL: Never call a blot "safe" or "without risk" without probability calculation
- CRITICAL: Single checkers on points 1-6 are ALWAYS blots, never "safe slots"
- CRITICAL: Prefer moves that create ZERO blots over moves that create any blots, unless the positional advantage is overwhelming
- CRITICAL: For move combinations, analyze FINAL board state, not intermediate states that get corrected by subsequent moves

RACE CALCULATION:
- Pip count = total distance needed to bear off all checkers
- WHITE pip count = Σ(number_of_checkers × absolute_point_number) for all points
- BLACK pip count = Σ(number_of_checkers × relative_point_number) for all points
- BLACK's relative point number = (25 - absolute_point_number)
- Example: BLACK checker on point 19 = relative point (25-19) = 6
- Both players start with equal pip counts (167 each in standard position)
- NEVER assume race leads - always calculate actual pip totals with math

SLOTTING CLARIFICATION:
- Only use "slotting" when moving to a completely EMPTY point
- Do NOT use "slotting" for moves to points that already have checkers
- Example: "13/8 slots the 8-point" (correct - 8 was empty)
- Example: "13/8 moves to the 8-point" (if 8 already had checkers)

STRATEGIC PRINCIPLES:
- You are playing as WHITE, so analyze from WHITE's viewpoint
- Evaluate moves using comprehensive strategic scoring across 7 weighted factors
- Calculate TOTAL SCORE = (Hitting × 10) + (Development × 9) + (Safety × 8) + (Pressure × 8) + (Diversity × 8) + (Timing × 7) + (Flexibility × 6)
- Choose move with highest total score

STRATEGIC FACTOR DEFINITIONS:
HITTING (×10): Potential to hit opponent blots - immediate tempo and disruption
DEVELOPMENT (×9): Board control and point-making - structural position improvement
SAFETY (×8): Risk of being hit - probability of losing checkers
PRESSURE (×8): Initiative and opponent forcing - creating difficulties for opponent
DIVERSITY (×8): Checker spreading/unstacking - creating multiple threats and tempo
TIMING (×7): Race position and tempo - pip count and race advantages
FLEXIBILITY (×6): Future roll options preservation - maintaining move adaptability

COMPREHENSIVE STRATEGIC EVALUATION METHODOLOGY:

HITTING ANALYSIS (0-10 scale):
- Scan opponent positions for hittable blots (single checkers)
- Calculate hit probability and strategic impact
- Rate based on tempo gained, disruption caused, follow-up potential
- 10: Hits critical blot with high probability, major advantage
- 8: Hits important blot, good tempo gain
- 5: Hits minor blot, small advantage
- 0: No hitting opportunities

DEVELOPMENT ANALYSIS (0-10 scale):
- CRITICAL: Check FINAL board state after ALL moves to identify made points
- RECOGNIZE POINT-MAKING: When multiple moves land on same point, creating 2+ checkers = made point
- Assess point-making opportunities and anchor creation
- Evaluate prime building and board control improvements
- Rate structural position enhancement

POINT-MAKING RECOGNITION:
□ After analyzing move combination, check FINAL board state
□ Identify any points that now have 2+ checkers (made points)
□ Determine if this is a NEW made point (was empty or had 1 checker before)
□ Or STRENGTHENING existing made point (already had 2+ checkers)

POINT-MAKING DEVELOPMENT VALUES:
- Making key home board points (1-6): 7-9 (high value - bear-off advantage)
- Making outer board points (7-12): 6-8 (good value - board control)
- Making opponent home board points (19-24): 8-10 (very high value - anchor)
- Strengthening existing made points: 4-6 (moderate value)
- Just advancing without making points: 3-5 (low value)

EXAMPLES:
- 8/2 6/2: Creates 2-point (2 checkers) = Development 7-8 (NOT "no new points")
- 13/8 8/5: Strengthens 8-point (3→4 checkers) = Development 6-7
- 24/21 13/10: Creates two blots, no points = Development 3-4
- 8/3 6/3: Creates 3-point (2 checkers) = Development 8-9

RATING SCALE:
- 10: Creates crucial point or strong anchor in opponent territory
- 8-9: Makes valuable home board or outer board point
- 6-7: Makes point or significantly strengthens structure
- 4-5: Moderate structural improvement or point strengthening
- 2-3: Minor advancement without point-making
- 0-1: Weakens position or creates vulnerabilities

SAFETY ANALYSIS (0-10 scale):
- Calculate total hit probability for all blots created
- Assess vulnerability duration and impact severity
- Rate overall position safety
- 10: Zero risk, completely safe
- 8: Very low risk (<10% total hit probability)
- 6: Moderate risk (10-25% total hit probability)
- 4: High risk (25-50% total hit probability)
- 0: Severe risk (>50% total hit probability)

PRESSURE ANALYSIS (0-10 scale):
- Evaluate ability to force opponent responses and create difficulties
- Assess initiative gained and opponent restriction
- Rate tactical pressure and forcing moves
- 10: Forces opponent into terrible position, major initiative
- 8: Creates significant pressure and difficulties
- 6: Moderate opponent restriction
- 4: Minor pressure created
- 0: No pressure or opponent advantages created

DIVERSITY ANALYSIS (0-10 scale):
- Assess checker distribution and stacking levels
- Evaluate threat creation and tempo potential
- Rate checker spreading effectiveness
- 10: Perfect distribution, no stacks, maximum threats created
- 8: Excellent spread, multiple attack vectors, high activity
- 6: Good distribution, active position with some stacking
- 4: Moderate stacking, some flexibility limitations
- 0: Heavy stacking, inflexible position, limited threats

TIMING ANALYSIS (0-10 scale):
- Compare pip count changes and race position
- Assess tempo advantages gained or lost
- Rate race and timing improvements
- 10: Massive race advantage gained, opponent far behind
- 8: Significant timing improvement, good tempo gain
- 6: Neutral timing, maintains race equality
- 4: Slight timing disadvantage
- 0: Major race setback, opponent gains significant lead

FLEXIBILITY ANALYSIS (0-10 scale):
- Evaluate future roll option preservation
- Assess position adaptability for different dice
- Rate option maintenance and responsiveness
- 10: Maximum options preserved for all future rolls
- 8: Excellent flexibility, many good responses possible
- 6: Good options maintained, reasonable adaptability
- 4: Some limitations created, reduced options
- 0: Very restrictive position, few good future moves

ANALYSIS REQUIREMENTS:
- For combination moves, FIRST analyze the FINAL board state after ALL moves are applied
- Identify NET changes: which points gain/lose checkers, final blot counts, final point ownership
- CRITICAL: Check for MADE POINTS in final state - do multiple moves create 2+ checkers on same point?
- RECOGNIZE POINT-MAKING: When moves combine to make a point, this is significant development
- THEN analyze individual move components for tactical understanding
- CORRECTLY identify point ownership (never confuse WHITE's points with BLACK's points)
- Assess strategic value based on FINAL position, not intermediate states

STRATEGIC EVALUATION REQUIREMENTS:
- Rate each candidate move on ALL 7 strategic factors (0-10 scale) using the methodology above
- Calculate total strategic score for each move using the weighted formula
- Compare strategic scores between all alternatives
- Choose move with highest total strategic value
- Clearly explain factor ratings, calculations, and trade-offs in reasoning

CORRECT ANALYSIS EXAMPLES:
- Point 8: WHITE's outer board (safe, WHITE's territory - NOT "BLACK's home board")
- Point 13: BLACK's outer board (dangerous, BLACK's territory)
- Point 5: WHITE's home board (very safe, WHITE's territory - NOT "BLACK's point")
- Point 20: BLACK's home board (prime targeting location for blots)

HIT PROBABILITY EXAMPLES:
- Blot 4 spaces away: 15/36 ≈ 41.7% (11 direct + 4 indirect: 31,13,11,22) → HIGH RISK
- Blot 6 spaces away: 11/36 ≈ 30.6% (direct hits only) → MEDIUM RISK
- Blot 2 spaces away: 11/36 ≈ 30.6% (direct hits only) → MEDIUM RISK
- SPECIFIC EXAMPLE: WHITE moves 8/5 creating blot on point 5. BLACK can hit from point 1 (4 spaces away) with 15/36 ≈ 41.7% probability. This is HIGH RISK and generally should be avoided.

STRATEGIC EVALUATION EXAMPLES:

Move A: 13/8 8/5
- Hitting: 0 (no opponent blots hittable)
- Development: 7 (strengthens 8-point to 4 checkers)
- Safety: 2 (creates 41.7% hit risk blot on 5)
- Pressure: 4 (minor opponent restriction)
- Diversity: 5 (creates some spread but reduces options)
- Timing: 6 (neutral race impact)
- Flexibility: 5 (limits some future options)
TOTAL SCORE: (0×10) + (7×9) + (2×8) + (4×8) + (5×8) + (6×7) + (5×6) = 70 + 16 + 32 + 40 + 42 + 30 = 230

Move B: 8/3 6/3
- Hitting: 0 (no opponent blots hittable)
- Development: 8 (makes 3-point with 2 checkers - FINAL state shows point made)
- Safety: 9 (creates temporary low-risk blot, then safe)

POINT-MAKING RECOGNITION EXAMPLE:
Move: 8/2 6/2
- FINAL STATE: Point 2 has 2 checkers (made point created)
- Development: 7-8 (makes valuable 2-point anchor, NOT "no new points")
- CORRECT: "Makes 2-point with 2 checkers = Development 7-8"
- INCORRECT: "home advancement, no new points" - WRONG, point was made!
- Pressure: 6 (moderate opponent restriction)
- Diversity: 8 (excellent checker spreading)
- Timing: 7 (good home board advancement)
- Flexibility: 8 (maintains excellent options)
TOTAL SCORE: (0×10) + (8×9) + (9×8) + (6×8) + (8×8) + (7×7) + (8×6) = 72 + 72 + 48 + 64 + 49 + 48 = 353

Choose Move B: Superior total strategic value (353 vs 230)

COMBINATION ANALYSIS EXAMPLE:
- 8/3 6/3: Individual analysis might show "8/3 creates blot on 3", but FINAL RESULT after both moves shows blot eliminated
- Always analyze NET effect, not intermediate states that get corrected by subsequent moves

TERMINOLOGY EXAMPLES:
- ✅ "13/8 slots the empty 8-point" (correct - moving to empty point)
- ✅ "24/21 makes the 21-point" (correct - creating blockade)
- ✅ "13/8 moves to the occupied 8-point" (correct - if 8 already has checkers)

INCORRECT ANALYSIS TO AVOID:
- ❌ "slots the safe 8-point deep in BLACK's home board" (8 is WHITE's point!)
- ❌ "moves to BLACK's 5-point" (5 is WHITE's point!)
- ❌ "13/8 slots the 8-point" (if 8 already has checkers - wrong usage of "slotting"!)
- ❌ "opponent's outfield 13-point" (13 is BLACK's, but calling it "outfield" is confusing)
- ❌ "8/5 slots the 5-point without risk" (creates a blot with 41.7% hit probability!)
- ❌ "single checker is safe in home board" (points 1-6 can still be hit if opponent has nearby checkers!)

COGNITIVE CHECKLIST (MANDATORY - Complete mentally before responding):
□ STEP 1 COMPLETE: Did I inventory EVERY SINGLE point 1-24 individually? (Internal check - output strategic summary)
□ STEP 2 COMPLETE: Did I identify ALL blots systematically (only single checkers)?
□ STEP 3 COMPLETE: Did I check vulnerability for EACH blot methodically?
□ STEP 3.5 COMPLETE: Did I calculate EXACT hit probabilities for ALL blots (favorable_rolls/36)?
□ STEP 4 COMPLETE: Did I calculate pip counts using correct formulas (internal verification - output strategic summary)?
□ STRATEGIC EVALUATION: Did I rate ALL 7 strategic factors (0-10) for each candidate move?
□ POINT-MAKING CHECK: Did I check FINAL board state for made points created by move combinations?
□ DEVELOPMENT ACCURACY: Did I recognize when multiple moves create a point together (not just "advancement")?
□ SCORING CALCULATION: Did I calculate total scores correctly using the weighted formula?
□ MOVE SELECTION: Did I choose the move with highest total strategic value?
□ NO ASSUMPTIONS: Did I avoid all forbidden assumptions listed above?
□ SYSTEMATIC VERIFICATION: Did I double-check all conclusions against verified data?

If any checklist item is NO → STOP and reanalyze from Step 1

FINAL VALIDATION:
□ Did I check EVERY point 1-24 individually (internal verification for strategic summary)?
□ Did I calculate WHITE pips using absolute point numbers (internal verification)?
□ Did I calculate BLACK pips using (25 - point_number) formula (internal verification)?
□ Did I calculate EXACT hit probabilities for ALL blots (favorable_rolls/36)?
□ Did I rate ALL 7 strategic factors (0-10) for each candidate move?
□ Did I check FINAL board state for made points created by move combinations?
□ Did I properly recognize point-making (not just "advancement" when points are made)?
□ Did I calculate total strategic scores using correct weightings?
□ Did I choose move with highest total strategic value?
□ Did I avoid assuming race leads without actual mathematical calculation?
□ Did I check ALL opponent checkers for hit possibilities (no distance restrictions)?
□ Did I avoid summarizing ranges without individual verification?
□ Did I use ONLY the provided board state data?
□ Did I base all conclusions on methodical analysis, not assumptions?

Focus on: strategic positioning, avoiding unnecessary risks, and maintaining board control.

MANDATORY RESPONSE FORMAT:
BOARD_INVENTORY: [Strategic summary highlighting formations, primes, and key positions]
BLOT_ANALYSIS: [Systematic vulnerability assessment with hit probabilities: "Blot on point X: Risk level (probability%) - attackable from points [list] via [direct/indirect] hits"]
RACE_ANALYSIS: [WHITE: total pips, BLACK: total pips | race status and strategic implications]
STRATEGIC_ANALYSIS: [Comprehensive evaluation of all candidate moves using 7 strategic factors]

BEST_MOVE: [move number from the legal moves list above]
STRATEGIC_SCORING: [Detailed factor ratings and total score calculation for chosen move vs key alternatives]
REASONING: [Strategic trade-off explanation: "Move chosen because [explain factor balance and total score superiority]. Key trade-offs: [describe how factors balanced to achieve highest total value]."]
CONFIDENCE: [0.0-1.0 based on methodical analysis certainty]

CRITICAL: You MUST end your response with BEST_MOVE, REASONING, and CONFIDENCE sections exactly as formatted above. Do not truncate or abbreviate these sections.`
}

/**
 * Parse AI response
 */
function parseAIResponse(response, isBlackPlayer = false) {
  let processedResponse = response

  // If we flipped the board for BLACK player, translate colors back in the response
  if (isBlackPlayer) {
    processedResponse = response
      .replace(/\bWHITE\b/g, 'TEMP_WHITE')
      .replace(/\bBLACK\b/g, 'WHITE')
      .replace(/\bTEMP_WHITE\b/g, 'BLACK')
  }

  // Remove markdown formatting that might interfere with parsing
  processedResponse = processedResponse.replace(/\*\*/g, '')

  const lines = processedResponse.split('\n')
  let bestMove = null
  let reasoning = ''
  let confidence = 0.5

  // Track if we're capturing multi-line reasoning
  let capturingReasoning = false

  lines.forEach(line => {
    if (line.includes('BEST_MOVE:')) {
      const match = line.match(/BEST_MOVE:\s*(\d+)/)
      if (match) {
        bestMove = parseInt(match[1])
      }
      capturingReasoning = false
    } else if (line.includes('REASONING:')) {
      // Start capturing reasoning - may be on same line or following lines
      reasoning = line.replace(/.*REASONING:\s*/, '').trim()
      capturingReasoning = true
    } else if (line.includes('CONFIDENCE:')) {
      const match = line.match(/CONFIDENCE:\s*([\d.]+)/)
      if (match) {
        confidence = parseFloat(match[1]) || 0.5
      }
      capturingReasoning = false
    } else if (capturingReasoning && line.trim()) {
      // Continue capturing multi-line reasoning until we hit another section
      if (reasoning) {
        reasoning += ' ' + line.trim()
      } else {
        reasoning = line.trim()
      }
    }
  })

  return { bestMoveIndex: bestMove ? bestMove - 1 : null, reasoning, confidence }
}

/**
 * Validate AI suggestion and return move combination
 */
function validateAndReturnMove(aiAnalysis, moves) {
  const { bestMoveIndex, reasoning, confidence } = aiAnalysis

  if (bestMoveIndex >= 0 && bestMoveIndex < moves.length) {
    const selectedCombination = moves[bestMoveIndex]
    return {
      move: selectedCombination,
      reasoning: reasoning,
      confidence: confidence,
      source: 'ai'
    }
  }

  // Fallback to first combination if AI gave invalid index
  return {
    move: moves[0],
    reasoning: "AI suggestion invalid, using conservative move combination",
    confidence: 0.3,
    source: 'fallback'
  }
}

/**
 * Format move for display
 */
function formatMove(move) {
  if (move.moves) {
    // This is a combination of moves
    return move.description
  }
  const from = move.from === 0 ? 'bar' : move.from === 25 ? 'bar' : move.from
  const to = move.to === -1 ? 'off' : move.to === -2 ? 'off' : move.to
  return `${from}/${to}`
}
